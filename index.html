<html>
    <head>
        <style>
            .strikethrough{
                text-decoration: line-through;
            }
            .displayNone{
                display:none;
            }
        </style>
    </head>
    <body>
        <p id="title">タイトル</p>
        <p id="timer">0:05</p>
        <ol id="taskList">
            <li>1つめの項目</li>
            <li>2つめの項目</li>
            <li>3つめの項目</li>
            <li id="inputTaskList"><input type="text" id="inputTask"></li>
        </ol>
        <!-- <input type="hidden" id="stopFlg" value=""> -->
        <button id="bt">button</button>
        <button id="bt2">next</button>
        <button id="bt3">delete</button>
        <button id="bt4">timer</button>
        <button id="bt5">start</button>
        <button id="bt6">stop</button>
        <button id="bt7">back</button>
        <button id="bt8"> < </button>
        <button id="bt9"> > </button>
        <button id="bt10">init</button>
    </body>
<script src="./Sortable.js"></script>
<script>
let speach = new SpeechSynthesisUtterance();
let timeLimit;
(()=>{
    setEvent();
    let sortable = Sortable.create(taskList, {
        group: "taskList",
        animation: 100
    });
})();

function setEvent(){
    bt.addEventListener('click',()=>{
        console.dir(taskList);
    });
    bt2.addEventListener('click',()=>{nextTask()});
    bt3.addEventListener('click',()=>{deleteEndTask()});
    bt4.addEventListener('click',()=>{timeCount(document.getElementById('timer'))});
    document.querySelectorAll('li:not(#inputTaskList)').forEach((li)=>{
        li.addEventListener('click',(e)=>{
            let strikethroughFlg = checkClass(e.target,"strikethrough");
            if(strikethroughFlg){
                li.classList.remove('strikethrough');
            }else{
                li.classList.add('strikethrough');
            }
        });
    });

    bt5.addEventListener('click',()=>{        
        start();
    });
    bt6.addEventListener('click',()=>{
        stop();
    });
    inputTask.addEventListener('keypress', function (e) {
        var ele = checkKeyPress(e,13,taskMake);
    });
    bt7.addEventListener('click',()=>{previousTask()});
    bt8.addEventListener('click',()=>{back2()});
    bt9.addEventListener('click',()=>{next2()});
    bt10.addEventListener('click',()=>{initTime()});
}



/*   clickEvent  */

/**
 * Changing the order in the ToDoList 
 * method for clickEvent
 */
let nextTask=()=>{
    console.log('nextTask()');
    let list = document.getElementById('taskList');
    let task = list.getElementsByTagName('li');
    if(task.length > 0){
        sequentialLoopList(list);
        list.appendChild(inputTaskList);
        return task;
    }
    return null;
};


let previousTask=()=>{
    console.log('previousTask()');
    let list = document.getElementById('taskList');
    let task = list.getElementsByTagName('li');
    console.dir(task);
    if(task.length > 0){
        reverseLoopList(list);
        list.appendChild(inputTaskList);
        return task;
    }
    return null;
};


let getTaskLength=()=>{
    let list = document.getElementById('taskList');
    return list.getElementsByTagName('li').length;
}

let next2 = () =>{
    // stopFlg.value = "stop";
    timeLimit.stop();

    nextTask();
    initTime();
    playTask();
}


let back2 = () =>{
    timeLimit.stop();
    previousTask();
    initTime();
    playTask();
}





/**
 * Delete if strikethroughLine is drawn 
 * method for clickEvent
 */
 let deleteEndTask=()=>{
     console.log('deleteEndTask()');
    //取り消し線が書かれているものを消す
    htmlElementAllDelete(document.getElementsByClassName('strikethrough'));
};

/**
 * display of time
 * method for clickEvent
 */
 let timeCount = async (dispTimer)=>{
    console.log("timeCount()");
    timeLimit = new TimeLimit(dispTimer.innerText,":");
    let timeObj = timeLimit;
    let endObj = await everySecond(()=>{
        let loopFlg = true;
        let limit = timeObj.calcLimitTime();
        let time = timeObj.getTime();
        if(limit <= -1){
            time = "0:00";
            loopFlg = false;
        }        
        if(timeObj.getFlg() != false){            
            dispTimer.innerText = timeObj.getTimeStr(time);
        }
        return loopFlg;
    },timeObj);
    return endObj;
};





/**
 * Changing the order in the List
 * @param   {HTMLElement} List
 * @return  {HTMLElement} List  
 */
let sequentialLoopList=(list)=>{
    // addTaskList(list.children[0]);
    list.appendChild(list.children[0]);
};

/**
 * Changing the order in the List
 * @param   {HTMLElement} List
 * @return  {HTMLElement} List  
 */
let reverseLoopList=(list)=>{
    list.insertBefore(list.lastElementChild, list.children[0]);
    list.insertBefore(list.lastElementChild, list.children[0]);
};



/**
 * Delete All HTMLElement 
 * @param   {HTMLElement} Delete target
 */
let htmlElementAllDelete=(delElement)=>{
    while (delElement.length > 0) {
        delElement.item(0).remove();
    }
}




/**
 * What to do every second
 * recursiveCall
 * @param   {callback} callback every second
 */
let everySecond = (callback,timeLimitObj)=>{
    return new Promise((res)=>{
        setTimeout(async ()=>{
            let loopFlg = callback();
            if(loopFlg==true && timeLimitObj.getFlg() == true){
                await everySecond(callback,timeLimitObj);
            }
            res(timeLimitObj);
        },1000);
    });
}

/**
 * Loop if there is a task
 * recursiveCall
 * 
 */
let start = ()=>{
    console.log("start()");
    deleteInput();
    playTask();
}

let playTask = async ()=>{
    deleteEndTask();
    changeTitle();
    let endObj = await timeCount(document.getElementById('timer'));
    let taskCount = getTaskLength();
    if(taskCount > 0 && endObj.getFlg() == true){
        nextTask();
        initTime();
        playTask();
    }
}

let stop = ()=>{
    timeLimit.stop();
    addInput();
}



let initTime = ()=>{
    document.getElementById('timer').innerText = "0:05";
}




/**
 * 
 */
//時間用のクラス
class TimeLimit{
    constructor(dispTimer,splitTag){
        this.objNum = Math.floor(Math.random()*100);
        this.moveFlg = true;
        this.splitTag = splitTag;
        this.limitSec = this.timeStringToSec(dispTimer,splitTag);
        this.settingSec = this.limitSec;
        this.startTime = this.getCurrentTime();
    }
    getNum(){
        return this.objNum;
    }

    start(){
        this.moveFlg = true;        
    }
    stop(){
        this.moveFlg = false;
    }
    getFlg(){
        return this.moveFlg;
    }

    secToTimeString(){
        // console.log("this.limitSec:"+this.limitSec);
        let min = Math.floor(this.divide60(this.limitSec));
        // console.log("min:"+min);
        return String(min)+this.splitTag+String(this.limitSec-this.multipli60(min));
    }


    getTime(){
        return this.secToTimeString();
    }

    calcLimitTime(){
        this.limitSec=this.settingSec - this.elapsedTime();
        return this.limitSec;
    }

    timeStringToSec(dispTimer,splitTag){
        let tmpTimeArray = dispTimer.split(splitTag);  
        return this.multipli60(Number(tmpTimeArray[0]))+Number(tmpTimeArray[1]);
    }

    getSec(){
        return this.changeSce();
    }

    setSec(sec){}

    /**
     * return current time
     * @return  {Number} current time
     */
    getCurrentTime(){
        return Date.now()/1000;
    }

    /**
     * return start time
     * @return  {Number} current time
     */
    getStartTime(){
        return this.startTime;
    }

    /**
     * Elapsed time since obj was created
     * @return  {Number} elapsed time
     */
    elapsedTime(){
        return Math.floor(this.getCurrentTime()-this.startTime);
    }

    /**
     * Return the remaining time set in obj
     * @return  {Number} remain time
     */
    getRemainTime(){
        return this.calcLimitTime();
    }


    /**
     * 
     */
    changeSec(){
        //時分秒を秒数に変更
        return Number(this.hour*60*60)+Number(this.min*60)+Number(this.sec);
    }

    secToMin(sec){
        return this.divide60(sec);
    }

    secToHour(sec){
        return this.divide60(this.divide60(sec));
    }

    minToSec(min){
        // console.log("min:"+min);
        return min * 60;
    }

    divide60(num){
        return num/60;
    }

    multipli60(num){
        return num*60;
    }

    startSec(){
        this.sec = Number(this.sec)+1;
        return this;
    }
    margeTime(m,s){
        let sec = String(s);
        if(sec.length<2){
            sec="0"+sec;
        }
        return m +":"+ sec;
    }

    getTimeStr(){
        let min = Math.floor(this.secToMin(this.limitSec));
        let sec = this.limitSec - this.minToSec(min);
        let time = this.margeTime(min,sec);
        return time;
    }
}


/**
 * Confirm whether the enter key is pressed
 * @param   {Event} e EventObject
 * @param   {Integer} keyNum Enter Key is No.13
 * @param   {method} method callbackMethod
 */
let checkKeyPress = (e,keyNum,method)=>{
    var key = e.which || e.keyCode;
    if (key === keyNum) { // 13 is enter
        return method();
    }
};


let taskMake = ()=>{
    if(inputTask.value!=""){
        let Ele = document.createElement('li');
        Ele.innerText = inputTask.value;
        addTaskList(Ele);
        inputTask.value = "";
        inputTask.focus();
    }
}

let addTaskList = (Ele)=>{
    taskList.appendChild(Ele);
    taskList.appendChild(inputTaskList);
}

let deleteInput = ()=>{
    console.log("deleteInput()");
    inputTaskList.classList.add("displayNone");
}

let addInput = ()=>{
    inputTaskList.classList.remove('displayNone');
}

let checkClass = (ele,checkClass)=>{
    let checkFlag = false;
    let classes = ele.className;
    console.dir(classes);
    if(!classes)return checkFlag;
    classArray = classes.split(' ');
    classArray.forEach((className)=>{
        checkFlag = className == checkClass?true:checkFlag;
    });
    console.log(checkFlag);
    return checkFlag;
} 


//text to speechの実行
//シングルトンパターンに変更する
let tts = (speak)=> {
    var speach = new SpeechSynthesisUtterance();
    speach.text = speak; // 喋る内容
    speechSynthesis.speak(speach);// 発話実行
};

let changeTitle = ()=>{
    let titleText = taskList.children[0].innerText;
    title.innerText = titleText;
    console.log(title);
    tts(titleText);
}


</script>
</html>

<!---
TtoT
webstraeg
design
anime
--->